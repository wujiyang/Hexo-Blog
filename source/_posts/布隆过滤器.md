---
title: 布隆过滤器
date: 2024-08-03 16:51:16
index_img: /img/布隆过滤器/0.png
tags:
    - 布隆过滤器
    - 系统设计
categories:
    - 系统设计
---

布隆过滤器（英语：Bloom Filter）是 1970 年由布隆提出的。它实际上是一个很长的二进制向量和一系列随机映射函数。主要用于判断一个元素是否在一个集合中。

<!-- more -->  
## 1. 背景

通常我们要判断一个元素是否在某个集合中时，经常想到的方式是将集合中所有元素保存起来，然后通过比较进行确定。链表、树、散列表（又叫哈希表，Hash table）等数据结构都是这种思路。但是随着集合中元素数量的增加，这几种方式需要的存储空间也会呈现线性增长，最终达到瓶颈。上述三种结构的检索时间复杂度分别为O(n)，O(logn)，O(1)。

## 2. 算法介绍

### 2.1 原理

布隆过滤器包含一个位数组和一组哈希函数。位数组每个元素存储的都是比特位，元素占用空间很小；使用一组哈希函数的原因是为了降低哈希冲突。
- 初始状态：一个位数组，全部位置都置为0
![](/img/布隆过滤器/1.png)
- 数据加入：分别使用多个哈希函数对元素值进行计算，得到一组哈希值，将对应哈希值下标的数组值置为1
![](/img/布隆过滤器/2.png)
- 数据查找：对给定元素进行相同的哈希计算，判断每个位置的值是否都为1。如果值都为1，就认为这个元素存在，如果有一个值不唯一，就说明这个值不存在。  

📌 <font color="red">注意：布隆过滤器返回的结果是“可能存在”和“一定不存在”，不能提供“一定存在”的语义保证。因为可能有多个元素映射到同一个位置，导致误判。</font>    

### 2.2 误判
误判率（假阳性）：一个不存在的元素，可能会被误判为存在

#### 2.2.1 误判原因
- 哈希函数冲突：不同的哈希函数对元素进行映射时，可能会产生冲突，导致不同元素因素到位数组的相同位置。如下图所示：w的位置都已经是1，被认为w存在。
- 位数组大小限制：为减少空间占用，位数组大小有限。当存储的元素数量较多时，数据冲突可能性升高。 
![](/img/布隆过滤器/3.png)

#### 2.2.2 误判概率
布隆过滤器的误判，主要是因为哈希函数存在冲突导致，即不同的值可能映射到同一个位置。在进行误判率的分析时，主要受到以下变量的制约：
- m：布隆过滤器的长度，即数组的长度
- n： 集合中的元素个数
- k： 哈希函数的个数
![](/img/布隆过滤器/4.png)

- 误判率：指定m、n、k情况下的误判率计算
![](/img/布隆过滤器/5.png)
- 长度：数组长度可以根据期望的误判率和元素个数来判断
![](/img/布隆过滤器/6.png)
- 哈希函数计算：指定m和n的情况下，减少误判的最佳哈希个数
![](/img/布隆过滤器/7.png)  

推导过程：
- 添加1个元素，则任一比特为1的概率为：1/m，任一比特为0的概率：1-1/m；
- 添加1个元素，执行k次散列之后，则任一比特为0的概率：(1-1/m)^k，任一比特为1的概率：1-(1-1/m)^k；
- 如果添加n个元素，那么任一比特为0的概率：(1-1/m)^kn，任一比特为1的概率：1-(1-1/m)^kn；
- 如果将1个新的元素，添加到已存在n个元素的布隆过滤器中，则任一比特已经为1的概率与上面相同，概率为：1-(1-1/m)^kn。因此，k个比特都为1的概率为：(1-(1-1/m)^kn)^k，此即为新插入元素的误识别率。

### 2.3 无法删除
布隆过滤器不允许删除元素：如果删除某个元素，导致对应位置为0，但是可能有多个元素映射到相同的位置上面，这样就会导致一个存在的元素被判断为不存在。破坏了“一定不存在”的语义保证。

📌 <font color="red">不允许删除的机制会导致其中的无效元素可能会越来越多，即实际已经在磁盘删除中的元素，但在布隆过滤器中还认为可能存在，这会造成越来越多的误判</font>   

### 2.4 优缺点总结
优点：
- 插入、查询的效率高，时间复杂度为常数O(k)
- 空间占用小（存储空间占用是一个固定长度的bit数组）
- 散列函数相互之间没有关系，可以并行Hash
- 不存储原始数据，在严格要求保密的场景下有优势
缺点：
- 存在误报的可能性，尤其数据量越大越容易误报
- 只支持新增，不支持删除
- 数组长度和hash函数个数确定复杂
- 当过滤器数组过长时，查询性能差（多个哈希得到的下标跨度很大，CPU缓存命中率低）

## 3. 应用场景
布隆过滤器在实际项目开发中可以快速地解决一些问题，比如网页 URL 去重、垃圾邮件识别、大集合中重复元素的判断和缓存穿透等问题。
典型应用有：
- 数据库防止穿库。 Google Bigtable，HBase 和 Cassandra 以及 Postgresql 使用BloomFilter减少不存在的行或列的磁盘查找。避免代价高昂的磁盘查找会大大提高数据库查询操作的性能。
- 业务场景中判断用户是否阅读过某视频或文章：比如抖音或头条，当然会导致一定的误判，但不会让用户看到重复的内容。
- 缓存穿透场景。在一些恶意请求中，请求参数都是缓存和数据中不存在的值，为了避免缓存穿透，可以用布隆过滤器先筛选一遍，只有在布隆过滤器中，才去查询缓存，如果没查询到，则穿透到db。如果不在布隆器中，则直接返回。
- WEB拦截器，如果相同请求则拦截，防止重复被攻击。可以提高缓存命中率。Squid 网页代理缓存服务器在 cache digests 中就使用了布隆过滤器。Google Chrome浏览器使用了布隆过滤器加速安全浏览服务 

## 4. 实现
基于Golang实现
```go
package main

import (
	"fmt"

	"github.com/bits-and-blooms/bitset"
)

// 设置哈希数组默认大小为16
const DefaultSize = 16

// 设置种子，保证不同哈希函数有不同的计算方式
var seeds = []uint{7, 11, 13, 31, 37, 61}

// 构造6个哈希函数，每个哈希函数有参数seed保证计算方式的不同
func buildHash() func(seed uint, value string) uint {
	return func(seed uint, value string) uint {
		var result uint = 0
		for i := 0; i < len(value); i++ {
			result = result*seed + uint(value[i])
		}
		return result & (DefaultSize - 1)
	}
}

// 布隆过滤器结构，包括二进制数组和多个哈希函数
type BloomFilter struct {
	set       *bitset.BitSet
	hashFuncs [6]func(seed uint, value string) uint
}

// 构造一个布隆过滤器，包括数组和哈希函数的初始化
func NewBloomFilter() *BloomFilter {
	bf := new(BloomFilter)
	bf.set = bitset.New(DefaultSize)

	for i := 0; i < len(bf.hashFuncs); i++ {
		bf.hashFuncs[i] = buildHash()
	}
	return bf
}

// Add 添加元素，将哈希函数计算结果对应的数组位置1
func (b *BloomFilter) Add(value string) {
	for i, f := range b.hashFuncs {
		b.set.Set(f(seeds[i], value))
	}
}

// Contains 查询元素是否存在，调用每个哈希函数，并且判断数组对应位是否为1 如果不为1，直接返回false，表明一定不存在
func (b *BloomFilter) Contains(value string) bool {
	for i, f := range b.hashFuncs {
		if !b.set.Test(f(seeds[i], value)) {
			return false
		}
	}
	return true
}

func main() {
	filter := NewBloomFilter()
	filter.Add("hello")
	filter.Add("world")
	fmt.Println(filter.Contains("hello"))
	fmt.Println(filter.Contains("world"))
	fmt.Println(filter.Contains("xiao"))
	fmt.Println(filter.Contains("xiaoming")) // 出现误判
}
```

## 5. 演进变体
针对布隆过滤器的上述一些问题，逐步产生了一些布隆过滤器的变体，简单介绍如下：

### 5.1 计数布隆过滤器 Counting Bloom Filter
- 特点：支持删除
- 原理：CountingBloomFilter是BloomFilter的一个变种，它扩展标准布隆过滤器的数据结构，将底层数组的每一位扩展为一个4位大小的计数器Counter，用来存储某个下标映射成功的频次。它以占用更多的空间来换取支持删除操作。
1. 插入元素时，通过k个哈希函数映射到k个计数器，这些命中的计数器值增加1；
2. 删除元素时，删除元素的时候，通过k个散列函数映射到k个计数器，这些计数器值减少1。
![](/img/布隆过滤器/8.png)  

优点：
- 除了占用存储空间翻（多）倍，继承了布隆过滤器的所有优点；支持删除。  

缺点：
- 误报的概率仍然存在
- 需要额外考虑 Counter 数组中每个 Counter 的大小（最好具备溢出策略）
- 存储空间较布隆过滤器翻（多）倍

### 5.2 扩展布隆过滤器 Scalable Bloom Filter
- 特点：支持扩容
- 原理：Scalable Bloom Filter只会向最后一层插入数据，同时也从最后一层开始查询，直到查询至 BF0 层。
![](/img/布隆过滤器/9.png)  
1. 插入过程：只会向最后一层插入数据
    1. 初始，SBF只包含BF0这一层，插入了a、b、c三个元素。
    2. 然后，假设BF0已经无法保证用户设定的误判率，此时就需要进行扩容，因此新的一层BF1被创建并加入进来。后来的d、e、f元素都会被插入到BF1中。
    3. 同理，当BF1也无法满足该层事先设定的误判率时，新的一层BF2也将被加入进来，如此进行下去。
2. 查询过程：从最后一层开始由后向前查询
    1. 首先在BF1中进行查询。如果查询显示存在，则直接响应客户端；
    2. 如果查询显示不存在，则继续查询BF0。如果BF0中显示存在g，则响应客户端g存在。否则，因为BF0已经是最后一层了，则响应客户端g不存在。
    
缺点：
- 查询开销：需要查询多个布隆过滤器，较单一布隆过滤器增加了一定的查询时间开销。
- 管理复杂度：维护多个布隆过滤器的策略相对复杂。
### 5.2 布谷鸟过滤器 Cuckoo Filter
布谷鸟过滤器是布隆过滤器的变体，提供了删除元素的功能。它主要基于布谷鸟哈希和指纹技术。当插入一个元素时，布谷鸟过滤器存储该元素的“指纹”到哈希表的某个位置上。如果该位置已被占用，现有的元素会被移动到另一个位置，如此迭代下去，直到每个元素都有自己的位置为止。

最简单的布谷鸟哈希结构是一维数组结构
1. 每个元素都由哈希函数h1(x)和h2(x)确定两个候选位置，查找过程会检查两个位置是否任意一个位置为空。
2. 如果两个位置中任何一个是空的，则算法将元素插入到该空位置中，插入完成；
3. 如果两个位置都是满的，会选择一个候选位置踢出去现有的元素(鸠占鹊巢)，并将此被踢出元素重新插入到它的备用位置。这个过程可能会重复，直到找到一个空位置或达到最大位移次数。如果没有找到空位置，则认为此哈希表太满，则进行扩容和ReHash后，再次插入。
![](/img/布隆过滤器/10.png)  

## 6. 参考资料

布隆过滤器：
https://segmentfault.com/a/1190000021136424 
https://segmentfault.com/a/1190000024566947

计数布隆过滤器：
https://juejin.cn/post/7362729128477638675 

布谷鸟过滤器：
https://www.cnblogs.com/zhaodongge/p/15067657.html
https://dbwu.tech/posts/cuckoo_filter/